package gov.dcsa.services;

import gov.dcsa.common.utilities.AuditManager;
import gov.dcsa.models.LookupDTO;
import gov.dcsa.models.admin.AddCoscAutoCompleteDTO;
import gov.dcsa.models.admin.EditTicketWorkflowDTO;
import gov.dcsa.models.admin.GetAssignableUserDTO;
import gov.dcsa.models.admin.GetCoscDTO;
import gov.dcsa.models.admin.GetExceptionDTO;
import gov.dcsa.models.admin.*;
import gov.dcsa.common.utilities.Constants;
import org.apache.commons.lang3.StringUtils;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.jdbc.support.rowset.SqlRowSet;
import org.springframework.stereotype.Service;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.sql.DataSource;
import java.util.*;

@Service("gov.dcsa.controllers.AdminService")
public class AdminService {

    @Resource
    private DataSource dataSource;

    @Resource
    private DatabaseService databaseService;

    @Resource
    private UserService userService;

    @Resource
    private AssignmentService assignmentService;

    @Resource
    private HistoryService historyService;

    @Resource
    private EmailService emailService;
    public final int LAST_1_DAY_FILTER = 1;
    public final int LAST_7_DAY_FILTER = 2;
    public final int LAST_30_DAY_FILTER = 3;
    public final int YEAR_TO_DATE_FILTER = 4;
    public final int ALL_DATA_FILTER = 5;

    private BeanPropertyRowMapper<GetExceptionDTO> rowMapperForGetExceptionDTOs;

    @PostConstruct
    public void init() {
        this.rowMapperForGetExceptionDTOs = new BeanPropertyRowMapper<>(GetExceptionDTO.class);
    }


    /**
     * Return the COSC Country List
     * @return List of GetCoscDTO objects
     */
    public List<GetCoscDTO> getListOfCoscInfo() {

        String sql =
                "select c.id, c.name as name, c.code as country_code, string_agg(CAST(a.name as varchar), ', ' order by a.name) as csvAliases\n" +
                "from countries c\n" +
                "join cosc_countries cc ON (c.id = cc.country_id AND cc.is_deleted = false)\n" +
                "left join countries_aliases ca on (c.id = ca.country_id AND ca.is_deleted=false)\n" +
                "left join aliases a on (ca.alias_id = a.id)\n" +
                "group by 1, 2, 3\n" +
                "order by 2";


        // Create a JdbcTemplate object
        JdbcTemplate jt = new JdbcTemplate(this.dataSource);

        // Use the rowMapper to convert the results into a list of ReportDTO objects
        BeanPropertyRowMapper<GetCoscDTO> rowMapper = new BeanPropertyRowMapper<>(GetCoscDTO.class);

        // Get a connection from the connection pool
        // Run the SQL, convert the resultSet into a list of GetCoscDTO objects, close the connection
        List<GetCoscDTO> listOfCoscDtos = jt.query(sql, rowMapper);

        return listOfCoscDtos;
    }

    /**
     * Remove this country from the COSC List
     * NOTE:  The actual database record is *NOT* deleted.  Instead the is_deleted flag is set to True
     * @param aCountryId Holds the unique country_id
     */
    public void removeCountryFromCoscList(Integer aCountryId) {

        AuditManager auditManager = new AuditManager(dataSource, userService.getLoggedInUserName() );

        // Construct the SQL to update the COSC_COUNTRIES table and add an audit record to COSC_COUNTRIES_AUD
        String sql = "update cosc_countries SET is_deleted=true, last_update_date=now(), last_update_user=:last_update_user " +
                     "where country_id=:country_id AND is_deleted=false";

        Map<String, Object> paramMap = new HashMap<>();
        paramMap.put("country_id", aCountryId );
        paramMap.put("last_update_user", userService.getLoggedInFullName() );

        // Execute the SQL to update this record  (and add an audit record)
        auditManager.runSqlUpdateOne(sql, paramMap, "cosc_countries_aud");
    }


    /**
     * @param aCountryId holds the unique country_id
     * @return true if the passed-in aCountryId exists in the countries table
     */
    public boolean doesCountryIdExist(Integer aCountryId) {
        // Construct the SQL to see if this record exists in the countries table
        String sql = "select id from countries where id=? and is_deleted=false";

        JdbcTemplate jt = new JdbcTemplate(this.dataSource);

        SqlRowSet rs = jt.queryForRowSet(sql, aCountryId);

        // Return false if the countryId does not exist
        // Return true if the countryid does exist
        return rs.next();
    }

    /**
     * @param aCountryId holds the unique country_id
     * @return true if the passed-in aCountryId exists in the cosc_countries table
     */
    public boolean doesCountryIdExistInCoscList(Integer aCountryId) {
        // Construct the SQL to see if this record exists in the cosc_countries table
        String sql = "select country_id from cosc_countries where country_id=? and is_deleted=false";

        JdbcTemplate jt = new JdbcTemplate(this.dataSource);

        SqlRowSet rs = jt.queryForRowSet(sql, aCountryId);

        // Return false if the countryId does not exist
        // Return true if the countryid does exist
        return rs.next();
    }

    /**
     * @param aPartialCountryName holds a partial company name to search against
     * @return a list of AddCoscAutoCompleteDTO objects
     *
     * NOTE:  The country name will include the string (in COSC) if the country name is already in the COSC list)
     */
    public List<AddCoscAutoCompleteDTO> getCoscMatchesByCompanyName(String aPartialCountryName,
                                                                    Integer aMaximumNumberOfMatches) {

        // Construct the sql to get the list of matches
        // NOTE:  The ORDER BY clause is odd
        //         1) I want to order entries that start with the partial match *FIRST*
        //         2) I want to order other entries *SECOND*
        String sql ="select c.id as country_id, c.name as country_name, c.code as country_code, " +
                    "       case when cc.country_id is null then false else true end as is_in_list, " +
                    "       string_agg(CAST(a.name as varchar), ', ' order by a.name) as csvAliases " +
                    "from countries c " +
                    "         left join cosc_countries cc ON (c.id = cc.country_id AND cc.is_deleted = false) " +
                    "         left join countries_aliases ca on (c.id = ca.country_id AND ca.is_deleted=false) " +
                    "         left join aliases a on (ca.alias_id = a.id) " +
                    "where c.name ilike :partial_name " +
                    "group by 1, 2, 3, 4 " +
                    "order by c.name ilike :partial_name_start DESC, c.name " +
                    "limit :total_matches";

        // Create the parameter map
        Map<String, Object> paramMap = new HashMap<>();
        paramMap.put("partial_name",       "%" + aPartialCountryName + "%");
        paramMap.put("partial_name_start", aPartialCountryName + "%");
        paramMap.put("total_matches",      aMaximumNumberOfMatches);

        // Create a JdbcTemplate object
        NamedParameterJdbcTemplate np = new NamedParameterJdbcTemplate(this.dataSource);

        // Create an empty list
        List<AddCoscAutoCompleteDTO> listOfDtos = new ArrayList<>();

        // Get a connection from the connection pool
        // Run the SQL, convert the resultSet into a list of AddCoscAutoCompleteDTO objects, close the connection
        SqlRowSet rs = np.queryForRowSet(sql, paramMap);

        while (rs.next() ) {
            String countryName;
            List<String> listOfAliases = null;

            int countryId = rs.getInt("country_id");
            String countryCode = rs.getString("country_code");
            boolean isInList = rs.getBoolean("is_in_list");
            String csvAliases = rs.getString("csvAliases");

            if (isInList) {
                countryName = rs.getString("country_name") + " (in COSC)";
            }
            else {
                countryName = rs.getString("country_name");
            }

            if (StringUtils.isNotEmpty(csvAliases)) {
                listOfAliases = Arrays.asList(csvAliases.split(",", -1));
            }

            // Create the one DTO object
            AddCoscAutoCompleteDTO addCoscDTO = new AddCoscAutoCompleteDTO(countryId, countryName, countryCode, isInList, listOfAliases);

            // Add the one DTO object to the list
            listOfDtos.add(addCoscDTO);
        }

        // Return the list of DTO objects back to the caller
        return listOfDtos;
    }

    public List<AddCoscAutoCompleteDTO> getCoscMatchesByCompanyCode(String aPartialCountryCode, Integer aMaximumNumberOfMatches) {

        // Construct the sql to get the list of matches
        // NOTE:  The ORDER BY clause is odd
        //         1) I want to order entries that start with the partial match *FIRST*
        //         2) I want to order other entries *SECOND*
        String sql ="select c.id as country_id, c.name as country_name, c.code as country_code, " +
                "       case when cc.country_id is null then false else true end as is_in_list, " +
                "       string_agg(CAST(a.name as varchar), ', ' order by a.name) as csvAliases " +
                "from countries c " +
                "         left join cosc_countries cc ON (c.id = cc.country_id AND cc.is_deleted = false) " +
                "         left join countries_aliases ca on (c.id = ca.country_id AND ca.is_deleted=false) " +
                "         left join aliases a on (ca.alias_id = a.id) " +
                "where c.code ilike :partial_code " +
                "group by 1, 2, 3, 4 " +
                "order by c.code ilike :partial_code_start DESC, c.name " +
                "limit :total_matches";

        // Create the parameter map
        Map<String, Object> paramMap = new HashMap<>();
        paramMap.put("partial_code",       "%" + aPartialCountryCode + "%");
        paramMap.put("partial_code_start", aPartialCountryCode + "%");
        paramMap.put("total_matches",      aMaximumNumberOfMatches);

        // Create a JdbcTemplate object
        NamedParameterJdbcTemplate np = new NamedParameterJdbcTemplate(this.dataSource);

        // Create an empty list
        List<AddCoscAutoCompleteDTO> listOfDtos = new ArrayList<>();

        // Get a connection from the connection pool
        // Run the SQL, convert the resultSet into a list of AddCoscAutoCompleteDTO objects, close the connection
        SqlRowSet rs = np.queryForRowSet(sql, paramMap);

        while (rs.next() ) {
            String countryName;
            List<String> listOfAliases = null;

            int countryId = rs.getInt("country_id");
            String countryCode = rs.getString("country_code");
            boolean isInList = rs.getBoolean("is_in_list");
            String csvAliases = rs.getString("csvAliases");

            if (isInList) {
                countryName = rs.getString("country_name") + " (in COSC)";
            }
            else {
                countryName = rs.getString("country_name");
            }

            if (StringUtils.isNotEmpty(csvAliases)) {
                listOfAliases = Arrays.asList(csvAliases.split(",", -1));
            }

            // Create the one DTO object
            AddCoscAutoCompleteDTO addCoscDTO = new AddCoscAutoCompleteDTO(countryId, countryName, countryCode, isInList, listOfAliases);

            // Add the one DTO object to the list
            listOfDtos.add(addCoscDTO);
        }

        // Return the list of DTO objects back to the caller
        return listOfDtos;
    }


    public void addCountryToCoscList(Integer aCountryId) {
        AuditManager auditManager = new AuditManager(dataSource, userService.getLoggedInUserName() );

        // Get a unique transaction id
        Integer newRecordId = this.databaseService.getNextTableId();

        String sql = "insert into cosc_countries(id, country_id, last_update_date, last_update_user) " +
                     "values(:new_record_id, :country_id, now(), :last_update_user)";

        Map<String, Object> paramMap = new HashMap<>();
        paramMap.put("new_record_id", newRecordId );
        paramMap.put("country_id", aCountryId );
        paramMap.put("last_update_user", this.userService.getLoggedInUserName() );

        // Execute the SQL to insert the record  (and add an audit record)
        auditManager.runSqlInsertOne(sql, paramMap, "cosc_countries_aud");
    }

    /**
     * @param aSelectedFilter holds the selected-filter-number
     * @return list of GetExceptionDTO objects
     */
    public List<GetExceptionDTO> getListOfExceptions(Integer aSelectedFilter) {

        String whereClause;
        if (aSelectedFilter == this.LAST_1_DAY_FILTER) {
            whereClause = "where e.event_date  BETWEEN (NOW() - INTERVAL '1 day') AND NOW() ";
        }
        else if (aSelectedFilter == this.LAST_7_DAY_FILTER) {
            whereClause = "where e.event_date  BETWEEN (NOW() - INTERVAL '7 days') AND NOW() ";
        }
        else if (aSelectedFilter == this.LAST_30_DAY_FILTER) {
            whereClause = "where e.event_date  BETWEEN (NOW() - INTERVAL '30 days') AND NOW() ";
        }
        else if (aSelectedFilter == this.YEAR_TO_DATE_FILTER) {
            // Limit to all records with event_date after january 1st of the current year and today
            whereClause = "where e.event_date  BETWEEN   date_trunc('year', now()) AND NOW() ";
        }
        else {
            whereClause = "";
        }

        String sql = "select e.id, e.app_name, e.app_version, e.cert_username as user_cert_name, u.full_name as user_full_name,\n" +
                     "       e.url, e.message, e.cause, e.stack_trace,\n" +
                     "       to_char(e.event_date, 'mm/dd/yyyy hh24:mi:ss') as event_date\n" +
                     "from exceptions e\n" +
                     "left join users u on (e.user_id = u.id)\n" +
                      whereClause +
                     "order by e.event_date desc";

        JdbcTemplate jt = new JdbcTemplate(this.dataSource);

        // Use the rowMapper to convert the results into a list of ReportDTO objects
        BeanPropertyRowMapper<GetExceptionDTO> rowMapper = new BeanPropertyRowMapper<>(GetExceptionDTO.class);

        // Execute the SQL and convert the result into a list of DTO objects
        List<GetExceptionDTO> listOfExceptionDTOs = jt.query(sql, rowMapper);

        return listOfExceptionDTOs;
    }

    public List<LookupDTO> getSubmittedApplicationStates(Integer aApplicationId) {
        String sql = "select id, display_name as value\n" +
                "from application_states\n" +
                "where id != ? and id != ?";

        BeanPropertyRowMapper<LookupDTO> rowMapper = new BeanPropertyRowMapper<>(LookupDTO.class);


        // Create JdbcTemplate object
        JdbcTemplate jt = new JdbcTemplate(this.dataSource);

        // Get a connection from the connection pool
        // Run the SQL
        // Return the connection to the connection pool
        List<LookupDTO> submittedApplicationStatesList = jt.query(sql, rowMapper, Constants.USER_STARTED_FILLING_IN_APPLICATION_STATE, Constants.SUBMITTED_APPLICATION_STATE);

        return submittedApplicationStatesList;
    }

    public List<GetAssignableUserDTO> getAssignableUsersForApplication(Integer aApplicationId) {

        Integer assignableRoleForApplicationState = getAssignableRoleForApplicationState(aApplicationId);

        String sql = "select u.id, full_name as fullName\n" +
                "from users as u\n" +
                "    left join users_internal_roles uir on u.id = uir.user_id\n" +
                "    left join applications a on a.id = ?\n" +
                "where uir.role_id = ? and uir.is_approved = true and (a.assigned_userid != u.id or a.assigned_userid is null)";

        BeanPropertyRowMapper<GetAssignableUserDTO> rowMapper = new BeanPropertyRowMapper<>(GetAssignableUserDTO.class);

        // Create JdbcTemplate object
        JdbcTemplate jt = new JdbcTemplate(this.dataSource);

        // Get a connection from the connection pool
        // Run the SQL
        // Return the connection to the connection pool
        List<GetAssignableUserDTO> submittedApplicationStatesList = jt.query(sql, rowMapper, aApplicationId, assignableRoleForApplicationState);

        return submittedApplicationStatesList;
    }

    public Integer getAssignableRoleForApplicationState(Integer aApplicationId) {

        String sql = "select state from applications where id = ?";

        // Create JdbcTemplate object
        JdbcTemplate jt = new JdbcTemplate(this.dataSource);

        Integer applicationState = jt.queryForObject(sql, Integer.class, aApplicationId);

        Integer roleIdForApplicationState = null;

        if (applicationState != null) {
            if (applicationState == Constants.ASSIGNED_TO_EM_APPLICATION_STATE) {
                roleIdForApplicationState = Constants.EM_ROLE_ID;
            } else if (applicationState == Constants.ASSIGNED_TO_EMTL_APPLICATION_STATE) {
                roleIdForApplicationState = Constants.EMTL_ROLE_ID;
            } else if (applicationState == Constants.ASSIGNED_TO_FOCIBA_APPLICATION_STATE) {
                roleIdForApplicationState = Constants.FOCIBA_ROLE_ID;
            } else if (applicationState == Constants.ASSIGNED_TO_FOCIBATM_APPLICATION_STATE) {
                roleIdForApplicationState = Constants.FOCIBATM_ROLE_ID;
            } else if (applicationState == Constants.ASSIGNED_TO_RMO_APPLICATION_STATE) {
                roleIdForApplicationState = Constants.RMO_ROLE_ID;
            } else if (applicationState == Constants.ASSIGNED_TO_MSM_APPLICATION_STATE) {
                roleIdForApplicationState = Constants.MSM_ROLE_ID;
            } else if (applicationState == Constants.ASSIGNED_TO_RMO_OVERSIGHT_APPLICATION_STATE) {
                roleIdForApplicationState = Constants.ORMO_ROLE_ID;
            }
        }

        return roleIdForApplicationState;
    }


    public List<TeamDTO> getAllTeams(Integer aApplicationStateId) {

        String sql = "";

        if (aApplicationStateId == Constants.ASSIGNED_TO_EM_APPLICATION_STATE || aApplicationStateId == Constants.ASSIGNED_TO_EMTL_APPLICATION_STATE){
            sql = 	"select id as id, team_name as teamName\n" +
                    "from entity_management_teams\n" +
                    "where is_approved = true\n" +
                    "order by teamName asc";
        }

        else if (aApplicationStateId == Constants.ASSIGNED_TO_FOCIBA_APPLICATION_STATE || aApplicationStateId == Constants.ASSIGNED_TO_FOCIBATM_APPLICATION_STATE){
            sql = 	"select id as id, team_name as teamName\n" +
                    "from foci_teams\n" +
                    "where is_approved = true\n" +
                    "order by teamName asc";
        }
        else if (aApplicationStateId == Constants.ASSIGNED_TO_RMO_APPLICATION_STATE || aApplicationStateId == Constants.ASSIGNED_TO_MSM_APPLICATION_STATE){
            sql = 	"select id as id, team_name as teamName\n" +
                    "from msm_teams\n" +
                    "where is_approved = true\n" +
                    "order by teamName asc";
        }

        BeanPropertyRowMapper<TeamDTO> rowMapper = new BeanPropertyRowMapper<>(TeamDTO.class);

        JdbcTemplate jt = new JdbcTemplate(this.dataSource);

        List<TeamDTO> allTeams = jt.query(sql, rowMapper);

        return allTeams;
    }

    public List<GetAssignableUserDTO> getAssignableUsersForTeam(Integer aApplicationId, Integer aTeamId) {

        Integer assignableRoleForApplicationState = getAssignableRoleForApplicationState(aApplicationId);

        BeanPropertyRowMapper<GetAssignableUserDTO> rowMapper = new BeanPropertyRowMapper<>(GetAssignableUserDTO.class);

        // Create JdbcTemplate object
        JdbcTemplate jt = new JdbcTemplate(this.dataSource);

        String sql;
        List<GetAssignableUserDTO> submittedApplicationStatesList;

        if(assignableRoleForApplicationState == Constants.EM_ROLE_ID){
            sql = "select u.id, full_name as fullName\n" +
                    "from users as u\n" +
                    "    left join users_internal_roles uir on u.id = uir.user_id\n" +
                    "    left join applications a on a.id = ?\n" +
                    "    join complexity_levels cl on (cl.max_level >= a.overall_complexity_score) and (cl.min_level <= a.overall_complexity_score)\n" +
                    "where uir.role_id = ? and uir.is_approved = true and u.emt_id = ? and (u.complexity_level >= cl.id) and (a.assigned_userid != u.id or a.assigned_userid is null)";

            submittedApplicationStatesList = jt.query(sql, rowMapper, aApplicationId, assignableRoleForApplicationState, aTeamId);
        }
        else if (assignableRoleForApplicationState == Constants.EMTL_ROLE_ID) {
            sql = "select u.id, full_name as fullName\n" +
                    "from users as u\n" +
                    "    left join users_internal_roles uir on u.id = uir.user_id\n" +
                    "    left join applications a on a.id = ?\n" +
                    "where uir.role_id = ? and uir.is_approved = true and u.emt_id = ? and (a.assigned_userid != u.id or a.assigned_userid is null)";

            submittedApplicationStatesList = jt.query(sql, rowMapper, aApplicationId, assignableRoleForApplicationState, aTeamId);
        }
        else if (assignableRoleForApplicationState == Constants.FOCIBA_ROLE_ID ||
                assignableRoleForApplicationState == Constants.ASSIGNED_TO_FOCIBATM_APPLICATION_STATE){
            sql = "select u.id, full_name as fullName\n" +
                    "from users as u\n" +
                    "    left join users_internal_roles uir on u.id = uir.user_id\n" +
                    "    left join applications a on a.id = ?\n" +
                    "where uir.role_id = ? and uir.is_approved = true and u.foci_team_id = ? and (a.assigned_userid != u.id or a.assigned_userid is null)";

            submittedApplicationStatesList = jt.query(sql, rowMapper, aApplicationId, assignableRoleForApplicationState, aTeamId);
        }
        else if (assignableRoleForApplicationState == Constants.RMO_ROLE_ID||
                assignableRoleForApplicationState == Constants.MSM_ROLE_ID){
            sql = "select u.id, full_name as fullName\n" +
                    "from users as u\n" +
                    "    left join users_internal_roles uir on u.id = uir.user_id\n" +
                    "    left join applications a on a.id = ?\n" +
                    "where uir.role_id = ? and uir.is_approved = true and u.msm_team_id = ? and (a.assigned_userid != u.id or a.assigned_userid is null)";

            submittedApplicationStatesList = jt.query(sql, rowMapper, aApplicationId, assignableRoleForApplicationState, aTeamId);
        }
        else {
            sql = "select u.id, full_name as fullName\n" +
                    "from users as u\n" +
                    "    left join users_internal_roles uir on u.id = uir.user_id\n" +
                    "    left join applications a on a.id = ?\n" +
                    "where uir.role_id = ? and uir.is_approved = true and (a.assigned_userid != u.id or a.assigned_userid is null)";

            submittedApplicationStatesList = jt.query(sql, rowMapper, aApplicationId, assignableRoleForApplicationState);
        }

        return submittedApplicationStatesList;
    }

    public void reassignTicket(EditTicketWorkflowDTO aEditTicketWorkflowDTO) {
        TransactionTemplate tt = new TransactionTemplate();
        tt.setTransactionManager(new DataSourceTransactionManager(dataSource));

        // This transaction will throw a TransactionTimedOutException after 60 seconds (causing the transaction to rollback)
        tt.setTimeout(Constants.SQL_TRANSACTION_TIMEOUT_SECS);

        tt.execute(new TransactionCallbackWithoutResult()
        {
            protected void doInTransactionWithoutResult(TransactionStatus aStatus) {
                try {
                    // All database calls in this block are part of a SQL Transaction

                    AuditManager auditManager = new AuditManager(dataSource, userService.getLoggedInUserName());

                    String sql = "";

                    if (aEditTicketWorkflowDTO.getPreviousApplicationStateId() == Constants.ASSIGNED_TO_EM_APPLICATION_STATE ||
                            aEditTicketWorkflowDTO.getPreviousApplicationStateId() == Constants.ASSIGNED_TO_EMTL_APPLICATION_STATE) {
                        // Construct the SQL to get these columns of data
                        sql = "with lead_set as (" +
                                "select u.emt_id from users u where u.id=:newAssignedUserId)" +
                                " update applications " +
                                "set assigned_userid=:newAssignedUserId, entity_management_team_id=(select emt_id from lead_set) " +
                                "where id = :ticketId ";
                    }
                    else if (aEditTicketWorkflowDTO.getPreviousApplicationStateId() == Constants.ASSIGNED_TO_FOCIBA_APPLICATION_STATE ||
                            aEditTicketWorkflowDTO.getPreviousApplicationStateId() == Constants.ASSIGNED_TO_FOCIBATM_APPLICATION_STATE) {
                        // Construct the SQL to get these columns of data
                        sql = "with lead_set as (" +
                                "select u.foci_team_id from users u where u.id=:newAssignedUserId)" +
                                " update applications " +
                                "set assigned_userid=:newAssignedUserId, foci_team_id=(select foci_team_id from lead_set) " +
                                "where id = :ticketId ";
                    }
                    else if (aEditTicketWorkflowDTO.getPreviousApplicationStateId() == Constants.ASSIGNED_TO_RMO_APPLICATION_STATE ||
                            aEditTicketWorkflowDTO.getPreviousApplicationStateId() == Constants.ASSIGNED_TO_MSM_APPLICATION_STATE) {
                        // Construct the SQL to get these columns of data
                        sql = "with lead_set as (" +
                                "select u.msm_team_id from users u where u.id=:newAssignedUserId)" +
                                " update applications " +
                                "set assigned_userid=:newAssignedUserId, msm_team_id=(select msm_team_id from lead_set) " +
                                "where id = :ticketId ";
                    }
                    else if (aEditTicketWorkflowDTO.getPreviousApplicationStateId() == Constants.ASSIGNED_TO_RMO_OVERSIGHT_APPLICATION_STATE) {
                        // Construct the SQL to get these columns of data
                        sql = " update applications " +
                                "set assigned_userid=:newAssignedUserId " +
                                "where id = :ticketId ";
                    }

                    Map<String, Object> paramMap = new HashMap<>();
//                    paramMap.put("newState", Constants.ASSIGNED_TO_EM_APPLICATION_STATE);
                    paramMap.put("newAssignedUserId", aEditTicketWorkflowDTO.getNewAssignedUserId());
                    paramMap.put("ticketId", aEditTicketWorkflowDTO.getApplicationId());

                    // Execute the SQL to update these records  (and add N audit records)
                    auditManager.runSqlUpdateOne(sql, paramMap, "applications_aud");


                    assignmentService.updateApplicationAssignedUserIdInElasticSearch(aEditTicketWorkflowDTO.getApplicationId(), aEditTicketWorkflowDTO.getNewAssignedUserId());
                    historyService.addHistoryRecordForAssigningTicket(aEditTicketWorkflowDTO.getApplicationId(), userService.getLoggedInUserId(),
                            aEditTicketWorkflowDTO.getNewAssignedUserId(), aEditTicketWorkflowDTO.getPreviousApplicationStateId(), aEditTicketWorkflowDTO.getPreviousApplicationStateId(),
                            auditManager);


                    // Send email to the newly assigned User  as long as that user is not myself... that would be annoying.
                    if (aEditTicketWorkflowDTO.getNewAssignedUserId() != userService.getLoggedInUserId()) {
                        emailService.sendEmailToNextAssignedUser(aEditTicketWorkflowDTO.getNewAssignedUserId());
                    }
                }
                catch(Exception e) {
                    RuntimeException re = new RuntimeException(e);
                    re.setStackTrace(e.getStackTrace());
                    throw re;
                }
            }
        });
    }
}
